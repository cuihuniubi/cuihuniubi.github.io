<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>JAVA | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


著作权归作者所有。
商业转载请联系作者获得授权，非商业转载请注明出处。
Mr.Zhang
链接：http://www.zh66.club/2019/09/05/canvas+mouse/
来源：さくら荘そのMr.Zhang

<script type="text/javascript" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Tsui&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">post</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Tsui&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">post</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">JAVA</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">John Doe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">October 15, 2019&nbsp;&nbsp;9:56:56</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p> 第二章：类和对象的创建</p>
<p>概念：面向对象就是把一个项目，一个事情分成更小的项目，或者说分成一个个更小的部分，每一部分负责什么方面的功能，最后再由这些部分组合而成为一个整体。</p>
<p>好处：面相对象更接近实物的本质，提高代码的复用更具有扩展性。</p>
<p>如何使用：通常是创建类的对象再给属性赋值。</p>
<p>构造方法：构造方法的名称和类名相同，没有返回值类型。</p>
<p>GO g=new GO();</p>
<p>构造方法的重载：方法名相同，参数列表不同，这是构造方法的重载。</p>
<p>如果一个类中包含了两个或两个以上的方法，他们方法名相同，方法参数个数或者参数类型不同，则称该方法被重载了，这个过程是方法重载。</p>
<p>Static：可以用来修饰属性，方法和代码块，静态方法中不能使用this和super关键字。</p>
<p>第三章：封装</p>
<p>概念：封装指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作访问。</p>
<p>好处：提高了安全性   提高了复用性  提高了实现细节</p>
<p>注意事项：类的属性中均用private来修饰  定义geter和seter方法</p>
<p>第四章：继承</p>
<p>概念：比如FeiGe快递系统中有三个实体类Person（人），Courier（快递员）,Customer（客户）类，Courier,Customer都属于（派生类）Person，所以都继承（extends）自Person类。</p>
<p>好处：提高了代码的重用性  提高了代码的扩展性</p>
<p>语法：class 类名 extends父接口{</p>
<p>   //属性定义</p>
<p>   //方法定义}</p>
<p>注意事项：1.子类继承父类所以的属性和方法，只不过只能调用非Private属性和方法2.java中的继承只支持单继承，意思是一个子类只能继承一个父类，但是允许多层继承       </p>
<p>继承中的构造方法：调用父类中的构造方法，</p>
<p>需用到关键字super super指代父类</p>
<p>重写的概念：在继承的关系中。子类会自动继承父类中定义的方法，但有时子类中需要对继承的方法进行一些修改，即对父类的方法进行重写。</p>
<p>语法：void 方法名（）{}</p>
<p>注意事项：子类重写父类的方法时，不能使用比父类中被重写的方法更严格的访问权限，重写方法和被重写方法必须具有相同的方法名，相同的参数列表和相同的返回值类型，重写方法的访问修饰符必须大于被重写方法的访问修饰符，否则就不能被称为方法的重写。</p>
<p>异常的处理：在程序执行代码的时候万一发生了异常，程序会按照预定的处理方法对异常进行处理，异常处理完毕之后，程序继续运行。</p>
<p>语法：5个关键字 try catch finally throw throws</p>
<p>常见的异常类型</p>
<p>Exception 异常层次的根类 ArithmeticException  算术错误情形，如以零作除数</p>
<p>ArrayIndexOutOfBoundsException  数组下标越界</p>
<p>NullPointerException空指针异常</p>
<p>ClassNotFoundException不能加载所需的类</p>
<p>InputMismatchException得到的数据类型与实际输入的类型不匹配</p>
<p>llegalArgumentException方法接收到非法参数</p>
<p>ClassCastException对象强制类型转换出错</p>
<p>NumberFormatException数字格式转换异常，如把“abc”转换成数字</p>
<p>第五章：多态</p>
<p>概念：指允许不同类的对象对同一消息做出响应即同同一消息可以根据发送对象的不同而采用多种不同的行为方式。</p>
<p>好处：可替换性 可扩充性 接口性 灵活性 简化性</p>
<p>多态的使用：</p>
<p>子类向父类转换称为向上转型</p>
<p>向上转型：&lt;父类型&gt;&lt;引用变量名&gt;=new&lt;子类型&gt;（）；</p>
<p>将一个指向子类对象的父类引用赋给一个子类的引用，即将父类类型转换子类类型，称为向下转型，此时必须进行强制类型转换。</p>
<p>向下转型：&lt;子类型&gt;&lt;引用变量名&gt;=（&lt;子类型&gt;）&lt;父类型的引用变量&gt;；</p>
<p>运算符：instanceof  进行类型的判断</p>
<p>Try-catch-finally 如果try中的所有语句正常执行完毕那么finally块就会被执行</p>
<p> 多重catch 一段代码会出现多种异常这时可以在try语句后写多个catch语句块</p>
<p>第六章：抽象</p>
<p>概念：如果一个类没有足够的信息去描述一个具体的对象那我们就称之为抽象类</p>
<p>语法：public abstract class类名{}</p>
<p>作用：抽象类是用来继承的比普通类更通用</p>
<p>抽象方法：abstract修饰没有方法体之声明返回的数据类型 方法名称和所需要的参数</p>
<p>语法 ：public abstract 返回值类型 方法名（参数列表）；</p>
<p>注意事项：包含抽象方法的类一定是抽象类  抽象类中不一定都是抽象方法  构造方法不能生命为抽象方法  abstract不能与private static final native 并列修饰同一个方法</p>
<p>Final 修饰类 被final修饰过的类不能被继承 因为不能被继承所以此类中所有方法都是final修饰   该类如果不需要有子类不需要被扩展类的方法不允许被重写就用final修饰该类</p>
<p>Throws通过try-catch捕获处理异常</p>
<p>第七章：接口</p>
<p>概述：在软件中接口是一种规范和标准他们可以约束类的行为是一些方法特征的集合但是没有方法的实现</p>
<p>语法：</p>
<p>【修饰符】interface接口名extends父接口1，父接口2……{//常量定义//方法定义}</p>
<p>Class类名extends父类名implements接口1，接口2….{//类成员}</p>
<p>Run（）；方法提供服务</p>
<p>接口是一种能力接口是一种约定</p>
<p>抛出异常：throw 除系统自动抛出异常可以用throw自动抛出异常</p>
<p>Throw在程序中抛出异常throws在方法内抛出异常</p>
<p>第八章：集合框架</p>
<p>集合框架使用方便的接口和类都在java.util包中</p>
<p>集合框架的特点：</p>
<p>长度  数组长度是固定的集合长度是可变的</p>
<p>存储对象 数组可以存储基本的数据类型，也可以存储对象的引用 集合只能用于存储对象的引用</p>
<p>对象类型 数组必须是相同类型的数据  对象可以是不同类型</p>
<p>  接口区别：</p>
<p>Collection接口存储组 不唯一(允许重复)、 无序的对象。<br> Set接口继承Collection接口，存储-组唯一(不允许重复)、 无序的对象。<br> List接口继承Collection接口，存储组不唯-(允许重复)、 有序(以元素插入的次序来放置无素，不会重新排列)的对象<br> Map接口存储组成对的键 值对象，提供key(键)到value(值)的映射。Map中的key不要求有序，不允许重复。value 同样不要求有序，但允许重复。</p>
<p>List接口：</p>
<p>实现List接口的常用类有ArayList和Lnkedist.它们都可以容纳所有类型的对象，包括nll允许重复，并且都保证元素的存储顺序。<br> ArrayList和LinkedList的大致区别:<br> arraylist是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构对于随机访问get和set, ArrayList 优于LinkedList, 因为LinkedList要移动指针。<br> 对于新增和删除操作add和remove, LinkedList 比较占优势，因为ArrayList要移动数据。</p>
<p>list接口定义中的格各种常用方法</p>
<p>boolean add(Object o)在列表末尾顺序添加元素，起始索引位置从0开始<br> int size()返回列表中的元素个数<br> void add(int index,Objecto)在指定的索 引位置添加元素，原索引位置及其后面的元素依次后移<br> 注意:新添加元素的索引位置必须介于0和列表中元素个数之间</p>
<p>0bject get(int index)返回指定索引位置处的元素<br> 注意:取出的元素是Object类型，使用前需要进行强制类型转换<br> boolean contains(Object o)判断列表中是否存在指定元素<br> boolean remove(Object o)从列表中删除元素<br> Object remove(int index)从列表中删除指定位置元素，起始索引位置从0开始</p>
<p>Linkedlist的一些特殊用法<br> void addFirst(Object o)在列表的首部添加元素<br> void addLast(Object o)在列表的末尾添加元素<br> Object getFirst( )返回列表中的第一” 个元素<br> Object getLast( )返回列表中的最后一个元素<br> Object removeFirst( )删除并返回列表中的第一个元素</p>
<p>Set接口</p>
<p>Hashset的优点就是各方面都很快但数据是无序的</p>
<p>Threeset优点是有序而且可以按照升序方式进行排序，但是其他各方面不突出</p>
<p>Map接口</p>
<p>Object put （object key，object value）以“键一值对”的方式进行存储<br> 如果武图添加重复的<br> 键，那么最后加入的“键-值对”将替换掉原先的“键一道<br> 对”<br> Object get (Object key)根据键返回相关联的值，若不存在指定的键，则返回null</p>
<p>Object remove (Object key)删除指定的键映射的“键一值对”<br> int size()返回元素个数<br> Set keySet()返回键的集合<br> Collection values( )返回值的集合<br> boolean containsKey (Object key)若存在指定的键映射的“键值对”，则返回true<br> boolean isEmpty( )若不存在键一值映射关系，则返回true<br> void clear()从此映射中移除所有映射关系<br> 泛型集合：list  ArrayList</p>
<p>ArrayL ist&lt;0bject&gt; list=new ArrayL ist&lt;0bject&gt;() ;</p>
<p>list. add (0);</p>
<p>list. add(99.9);</p>
<p>list. add(false);</p>
<p> 使用泛型集合在创建集合对象时指定集合中元素的类型，从集合中取出元素时无须进行类型强制转换，并且如果把非指定类型对象放入集合，会出现编译错误。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>John Doe</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/2019/10/15/JAVA/">http://yoursite.com/2019/10/15/JAVA/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2019/10/15/Github博客搭建/">Github博客搭建</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© John Doe | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
